# MemoRable Lambda Deployment
# Multi-stage build for AWS Lambda with Lambda Web Adapter
# Runs the MCP server in HTTP/StreamableHTTP mode — zero code changes needed
#
# Cost: ~$1-3/month (vs ~$122/month for the old ECS/ALB/NAT stack)
#
# Build:   docker build -f Dockerfile.lambda -t memorable-mcp .
# Test:    docker run -p 8080:8080 -e MONGODB_URI=<atlas_uri> memorable-mcp
#

# ─── Stage 1: Build (native module compilation) ───────────────────────
FROM public.ecr.aws/docker/library/node:20 AS builder

WORKDIR /app

# Copy package files first (Docker layer caching)
COPY package.json package-lock.json* ./

# Install production dependencies only
# node:20 has gcc/make/python3 for native modules (argon2, etc.)
# If @tensorflow/tfjs-node is problematic, it can be removed from
# package.json — it's not needed for core MCP tool operations.
RUN npm ci --omit=dev 2>&1 || \
    (echo "=== Full npm ci failed, retrying without native scripts ===" && \
     npm ci --omit=dev --ignore-scripts && \
     cd node_modules/argon2 && npx --yes node-pre-gyp install --fallback-to-build 2>/dev/null || true)

# Copy source and config
COPY src/ src/
COPY tsconfig.json ./

# ─── Stage 2: Runtime (slim + Lambda Web Adapter) ─────────────────────
FROM public.ecr.aws/docker/library/node:20-slim

# Lambda Web Adapter: bridges Lambda events ↔ HTTP requests
# When placed in /opt/extensions/, Lambda picks it up automatically.
# It starts our Express server and proxies Lambda events to it.
COPY --from=public.ecr.aws/awsguru/aws-lambda-web-adapter:0.8.4 \
     /lambda-adapter /opt/extensions/lambda-adapter

WORKDIR /var/task

# Copy compiled node_modules from builder (includes native .node files)
COPY --from=builder /app/node_modules ./node_modules

# Copy source and config
COPY --from=builder /app/src ./src
COPY --from=builder /app/package.json ./
COPY --from=builder /app/tsconfig.json ./

# Install tsx for TypeScript execution (matches dev workflow)
RUN npm install -g tsx

# ─── Lambda Web Adapter Configuration ─────────────────────────────────
# PORT: The adapter proxies Lambda events to this port
ENV PORT=8080

# Readiness check: adapter waits for this endpoint before routing traffic
ENV AWS_LWA_READINESS_CHECK_PATH=/health

# Response streaming: required for MCP StreamableHTTP (SSE responses)
ENV AWS_LWA_INVOKE_MODE=RESPONSE_STREAM

# ─── MCP Server Configuration ─────────────────────────────────────────
# HTTP transport mode (Express + StreamableHTTP)
ENV TRANSPORT_TYPE=http
ENV MCP_HTTP_PORT=8080

# Direct mode: connect to MongoDB Atlas (no intermediate REST API)
# DO NOT set API_BASE_URL or MEMORABLE_API_URL — that triggers REST mode
ENV NODE_ENV=production

# Start the MCP server — Express listens on :8080, adapter proxies to it
CMD ["tsx", "src/services/mcp_server/index.ts"]
