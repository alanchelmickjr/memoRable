name: Deploy to AWS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
  push:
    branches:
      - main
    paths:
      - 'src/**'
      - 'docker/**'
      - 'cloudformation/**'
      - '.github/workflows/**'

env:
  AWS_REGION: us-west-2
  # CloudFormation stack name (determines ECS cluster/service names)
  STACK_NAME: memorable

# Required for OIDC authentication with AWS
permissions:
  id-token: write   # Required for requesting the JWT
  contents: read    # Required for actions/checkout

jobs:
  # Check if AWS credentials are configured
  check-aws-config:
    runs-on: ubuntu-latest
    outputs:
      aws_configured: ${{ steps.check.outputs.configured }}
    steps:
      - name: Check AWS configuration
        id: check
        run: |
          if [ -z "${{ secrets.AWS_ACCOUNT_ID }}" ]; then
            echo "AWS_ACCOUNT_ID secret not configured - skipping deployment"
            echo "configured=false" >> $GITHUB_OUTPUT
          else
            echo "AWS credentials configured"
            echo "configured=true" >> $GITHUB_OUTPUT
          fi

  build-images:
    needs: check-aws-config
    if: needs.check-aws-config.outputs.aws_configured == 'true'
    runs-on: ubuntu-latest
    outputs:
      # Output just the tag - full URL gets masked by GitHub Actions because it contains AWS_ACCOUNT_ID
      image_tag: ${{ steps.build.outputs.image_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # OIDC Authentication - No secrets needed!
      # Requires: cloudformation/github-oidc.yaml deployed first
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/memorable-github-actions-memoRable
          role-session-name: github-actions-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repositories exist
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          # Create repositories if they don't exist
          for repo in memorable memorable-ingestion memorable-mcp; do
            aws ecr describe-repositories --repository-names $repo 2>/dev/null || \
            aws ecr create-repository --repository-name $repo --image-scanning-configuration scanOnPush=true
          done

      - name: Build and push images
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build and push main app
          docker build -t $ECR_REGISTRY/memorable:$IMAGE_TAG -f docker/Dockerfile .
          docker push $ECR_REGISTRY/memorable:$IMAGE_TAG
          docker tag $ECR_REGISTRY/memorable:$IMAGE_TAG $ECR_REGISTRY/memorable:latest
          docker push $ECR_REGISTRY/memorable:latest

          # Build and push ingestion service
          docker build -t $ECR_REGISTRY/memorable-ingestion:$IMAGE_TAG -f src/services/ingestion_service/Dockerfile .
          docker push $ECR_REGISTRY/memorable-ingestion:$IMAGE_TAG
          docker tag $ECR_REGISTRY/memorable-ingestion:$IMAGE_TAG $ECR_REGISTRY/memorable-ingestion:latest
          docker push $ECR_REGISTRY/memorable-ingestion:latest

          # Build and push MCP server
          docker build -t $ECR_REGISTRY/memorable-mcp:$IMAGE_TAG -f src/services/mcp_server/Dockerfile .
          docker push $ECR_REGISTRY/memorable-mcp:$IMAGE_TAG
          docker tag $ECR_REGISTRY/memorable-mcp:$IMAGE_TAG $ECR_REGISTRY/memorable-mcp:latest
          docker push $ECR_REGISTRY/memorable-mcp:latest

          # Output just the tag - full URLs get masked because they contain AWS account ID
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT

  ecs-deploy:
    needs: [check-aws-config, build-images]
    if: needs.check-aws-config.outputs.aws_configured == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/memorable-github-actions-memoRable
          role-session-name: github-actions-deploy-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy app service to ECS
        env:
          CLUSTER: ${{ env.STACK_NAME }}-cluster
          SERVICE: ${{ env.STACK_NAME }}-app
          # Reconstruct full URL here - can't pass through outputs because account ID gets masked
          NEW_IMAGE: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/memorable:${{ needs.build-images.outputs.image_tag }}
        run: |
          echo "Deploying $NEW_IMAGE to $CLUSTER/$SERVICE"

          # Get the current task definition ARN from the running service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster "$CLUSTER" \
            --services "$SERVICE" \
            --query 'services[0].taskDefinition' \
            --output text)

          echo "Current task definition: $TASK_DEF_ARN"

          # Get the full task definition
          aws ecs describe-task-definition \
            --task-definition "$TASK_DEF_ARN" \
            --query 'taskDefinition' > task-def.json

          # Update the container image to the new build
          jq --arg IMAGE "$NEW_IMAGE" \
            '.containerDefinitions[0].image = $IMAGE' \
            task-def.json > updated-task-def.json

          # Strip runtime-only fields that can't be passed to register-task-definition
          jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
            updated-task-def.json > register-task-def.json

          # Register the new task definition revision
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://register-task-def.json \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "New task definition: $NEW_TASK_DEF_ARN"

          # Update the ECS service with the new task definition
          aws ecs update-service \
            --cluster "$CLUSTER" \
            --service "$SERVICE" \
            --task-definition "$NEW_TASK_DEF_ARN" \
            --force-new-deployment

          echo "ECS service update initiated"

      - name: Wait for deployment to stabilize
        env:
          CLUSTER: ${{ env.STACK_NAME }}-cluster
          SERVICE: ${{ env.STACK_NAME }}-app
        run: |
          echo "Waiting for ECS service to stabilize..."
          # Wait up to 5 minutes for the new deployment to become stable
          for i in $(seq 1 30); do
            STATUS=$(aws ecs describe-services \
              --cluster "$CLUSTER" \
              --services "$SERVICE" \
              --query 'services[0].deployments[?status==`PRIMARY`].rolloutState' \
              --output text)

            echo "[$i/30] Deployment status: $STATUS"

            if [ "$STATUS" = "COMPLETED" ]; then
              echo "Deployment completed successfully!"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "Deployment failed! Check ECS console for details."
              exit 1
            fi

            sleep 10
          done

      - name: Health check
        run: |
          ALB_DNS="memorable-alb-1679440696.${{ env.AWS_REGION }}.elb.amazonaws.com"
          echo "Testing health endpoint at $ALB_DNS..."
          # Allow a few retries for the new task to register with the target group
          for i in $(seq 1 5); do
            if curl -sf "http://${ALB_DNS}/health/live" > /dev/null 2>&1; then
              echo "Health check passed!"
              exit 0
            fi
            echo "Attempt $i/5 - waiting..."
            sleep 10
          done
          echo "Health check did not pass within timeout - service may still be starting"

  notify:
    needs: [check-aws-config, build-images, ecs-deploy]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.check-aws-config.outputs.aws_configured }}" != "true" ]; then
            echo "**Status:** Deployment skipped (AWS_ACCOUNT_ID not configured)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To enable deployment, add the AWS_ACCOUNT_ID secret to this repository." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.ecs-deploy.result }}" == "success" ]; then
            echo "**Status:** Deployment successful!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Environment:** ${{ github.event.inputs.environment || 'staging' }}" >> $GITHUB_STEP_SUMMARY
            echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
            echo "**Image tag:** ${{ needs.build-images.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Infrastructure" >> $GITHUB_STEP_SUMMARY
            echo "- Auth: OIDC (no stored credentials)" >> $GITHUB_STEP_SUMMARY
            echo "- IaC: CloudFormation (stack: memorable)" >> $GITHUB_STEP_SUMMARY
            echo "- Deploy: ECS force-new-deployment" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Status:** Deployment failed!" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Check the workflow logs for details." >> $GITHUB_STEP_SUMMARY
          fi
